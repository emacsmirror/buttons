@setfilename buttons.info
@settitle Emacs Buttons Documentation
@setchapternewpage odd
@c %**end of header

@direntry
* Emacs Buttons             
@end direntry

* Defining buttons
@defmac {defbuttons} kmap-sym ancestor-kmap load-after-keymap-syms keymap
Define a keymap KMAP-SYM.

ANCESTOR-KMAP, if non-nil,is merged recursively onto
KMAP-SYM via DEFINE-KEYMAP-ONTO-KEYMAP.

LOAD-AFTER-KEYMAP-SYMS is a list of keymap symbols, bound or unbound,
onto which to define KMAP-SYM via AFTER-SYMBOL-LOADED-FUNCTION-ALIST.

KEYMAP is the keymap, for example, one defined via BUTTONS-MAKE
@end defmac

@defmac {buttons-make} key-mapper &rest bindings
Define an anonymous keymap.
BINDINGS... is a list of (KEY TARGET) pairs, where KEY
should be suitable to use as the KEY argument in DEFINE-KEY,
for example "<s-f1>".

TARGET may be any value that could be passed to the DEF
argument of DEFINE-KEY, including a command and a keymap,
including an anonymous keymap created with BUTTONS-MAKE.

KEY-MAPPER, if non-nil, is a function to apply to the
KEY of each binding before it is passed to DEFINE-KEY.
As an example, it may be used to add a modifier to
its input key to make the BINDINGS list more consice.
@end defmac


* Compact DLS for generating commands
@defmac {buttons-macrolet} more-macrolet-defs &rest body
Define 3-letter aliases for useful functions and macros
to provide a compact DLS for defining buttons
@end defmac

@defmac {buttons-insert-rec-template} &rest templates
Compile a string specificing a keyboard macro template into
   a progression of lisp command.

   Any directive @{DIRECTIVE@} within curly brackets is interpreted:

       If DIRECTIVE is the empty string, a recursive edit is
           entered for the user to type any text.

       If DIRECTIVE is a number K, and a string labeled K does not exist,
           a recursive edit is entered for the user to type any text. Upon exit,
           the substring in the current buffer between the markers
           before and after the recursive edit are stored as a string labeled K.
           If a string labeled K already exists, it is inserted.

       Otherwise, DIRECTIVE is interpreted as a function or macro, and
       expanded into the call: (DIRECTIVE)

    Any non-directive text is inserted literally.

    No escaping of the curly brackets is supported.

    Example:

    for ( int @{0@} = 0; @{0@} < @{@}; @{0@}++ )@{cbd@}

    Expands into:

        - insert 'for ( int '

        - enter recursive edit. upon exit, record the entered text as a string labeled 0

        - insert ' = ; '

        - insert the already-recoded string 0

        - insert ' < '

        - enter recursive edit, no recording is done

        - enter '; '

        - insert the already-recorded string 0

        - insert '++  )'

        - expand into the form: (cbd), which denotes the name a function or a macro
@end defmac

@defmac {buttons-defcmd} &rest body
Define an anonymous command with body BODY.
The number of times the command is invoked is recorded
as the USE-COUNT property of the function symbol.
This can be helpful for analysis and for making
decisions about which bindings' key-sequence
lengths are worth shortening.
@end defmac


* Visualization
@defun {buttons-display} keymap &optional hide-command-names-p hide-command-use-count-p
Visualize a keymap KEYMAP in a help buffer.
Unlike the standard keymap bindings help, nested keymaps
are visualized recurisvely. This is suitable for visualizing
BUTTONS-MAKE-defined nested keymaps.

If HIDE-COMMAND-NAMES-P is non-nil, command names are not displayed.

If HIDE-COMMAND-USE-COUNT-P is non-nil, no attempt is made to display recorded
command use-counts.

@end defun


* Internal
@defvar after-symbol-loaded-function-alist
An alist where each element has the form (SYMBOL . FUNCTION).
FUNCTION takes no arguments and is evaluated after SYMBOL has been bound.
If SYMBOL is currently bound, FUNCTION is called immediately.
@end defvar

@defun {define-keymap-onto-keymap} from-map to-map &optional from-sym no-overwrite-p
Define bindings FROM-MAP onto TO-MAP, recursively.
If a binding A in FROM-MAP doesn't exist on TO-MAP, define A onto TO-MAP.
Otherwise, if a binding is a prefix key on both maps, merge recursively.
Otherwise FROM-MAP's binding overwrites TO-MAP's binding
only when NO-OVERWRITE-P is non-nil.
@end defun



